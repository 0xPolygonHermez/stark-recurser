pragma circom 2.1.0;
pragma custom_templates;

<% for (let i = 0; i < verifierFilenames.length; ++i) { -%>
include "<%- verifierFilenames[i] %>";
<% } -%>
include "iszero.circom";

<%- include('src/vadcop/helpers/templates/verify_global_challenge.ejs', { vadcopInfo }); %>

<%- include('src/vadcop/helpers/templates/verify_global_constraints.ejs', { vadcopInfo }); %>

template Main() {

    signal input publics[<%- vadcopInfo.nPublics %>];

    signal input challenges[<%- vadcopInfo.numChallenges.reduce((nc, acc) => nc + acc, 0) + 4 %>][3];
    signal input challengesFRISteps[<%- vadcopInfo.stepsFRI.length + 1%>][3];

<%  for(let i = 0; i < vadcopInfo.aggTypes.length; ++i) { -%>
    signal input <%- `sv${i}` %>aggregationTypes[<%- vadcopInfo.aggTypes[starkInfo[i].subproofId].length %>];
<%- include('src/main_templates/define_stark_inputs.circom.ejs', { prefix: `sv${i}`, starkInfo: starkInfo[i], nPublics: vadcopInfo.nPublics }); %>
<%- include('src/main_templates/vadcop/define_vadcop_inputs.circom.ejs', { prefix: `sv_agg${i}`, vadcopInfo, starkInfo: starkInfo[i], subproofId: i, options: {...options, addPublics: false, isInput: true, isAggregation: true } }); %>
<%  } -%>

<%  for(let i = 0; i < vadcopInfo.aggTypes.length; ++i) { -%>
<%- include('src/main_templates/assign_stark_inputs.circom.ejs', { componentName: `sV${i}`, prefix: `sv${i}`, starkInfo: starkInfo[i], nPublics: vadcopInfo.nPublics, options }); %>
<%- include('src/main_templates/vadcop/assign_vadcop_inputs.circom.ejs', { componentName: `sV${i}`, prefix: `sv_agg${i}`, prefixStark: `sv${i}`, subproofId:i, vadcopInfo, options: { setEnableInput: vadcopInfo.aggTypes.length > 1  } }); %>

    var sv<%- i %>_rootCAgg[4] = [<%- aggregatedVK[i].join(",") %>];
    var sv<%- i %>_rootCBasics[<%- vadcopInfo.nAirs[i] %>][4];

    <% for(let j = 0; j < vadcopInfo.nAirs[i]; j++) { -%>
    sv<%- i %>_rootCBasics[<%- j %>] = [<%- basicVK[i][j].join(",") %>];
    <% } -%>

<%  if(vadcopInfo.aggTypes.length > 1) { -%>
    sV<%- i %>.rootC <== SelectVerificationKeyNull(<%- vadcopInfo.aggTypes.length %>)(sv<%- i %>_circuitType, sv<%- i %>_rootCBasics, sv<%- i %>_rootCAgg);
<%  } else { -%> 
    sV<%- i %>.rootC <== SelectVerificationKeyNull(<%- vadcopInfo.aggTypes.length %>)(sv<%- i %>_circuitType, sv<%- i %>_rootCBasics, sv<%- i %>_rootCAgg);
<%  } -%>
<%  } -%>

    // Calculate transcript and check that matches with the global challenges
    component verifyChallenges = VerifyGlobalChallenges();
    verifyChallenges.challenges <== challenges;
    verifyChallenges.challengesFRISteps <== challengesFRISteps;
    verifyChallenges.publics <== publics;
<%  for(let i = 0; i < vadcopInfo.aggTypes.length; ++i) { -%>
    verifyChallenges.rootC[<%- i %>] <== s<%- i %>_sv_rootC;
<%      for (let j = 0; j < vadcopInfo.numChallenges.length + 1; ++j) { -%>
    verifyChallenges.root<%- j + 1 %>[<%- i %>] <== s<%- i %>_sv_root<%- j+1 %>;
<%      } -%>
    verifyChallenges.evalsHash[<%- i %>] <== s<%- i %>_sv_evalsHash;
<%      for (let j = 1; j < vadcopInfo.stepsFRI.length; ++j) { -%>
    verifyChallenges.s<%- j %>_root[<%- i %>] <== s<%- i %>_sv_s<%- j %>_root;
<%      } -%>
    verifyChallenges.finalPolHash[<%- i %>] <== s<%- i %>_sv_finalPolHash;
<%  } -%>

    // Verify global constraints
    component verifyGlobalConstraints = VerifyGlobalConstraints();
    verifyGlobalConstraints.publics <== publics;
<%  for(let i = 0; i < vadcopInfo.aggTypes.length; ++i) { -%>
    verifyGlobalConstraints.s<%- i %>_subproofValues <== sv<%- i %>_subproofValues;
<%  } -%>
}

component main {public [publics]} = Main();
