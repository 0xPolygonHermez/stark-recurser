<%
class Transcript {
    constructor(name) {
        this.state = ["0", "0", "0", "0"];
        this.pending = [];
        this.out = [];
        this.hCnt = 0;
        this.hiCnt = 0;
        this.lastCodePrinted = 0;
        this.name = name;

        this.code = [];
    }


    getField(v) {
        this.code.push(`${v} <== [${this.getFields1()}, ${this.getFields1()}, ${this.getFields1()}];`);
    }

    updateState()  {
        let signalName = "transcriptHash";
        if(this.name) signalName += "_" + this.name;
        this.code.push(`\n    signal ${signalName}_${this.hCnt++}[12] <== Poseidon2(12)([${this.pending.join(',')}], [${this.state.join(',')}]);`);

        // Add unused transcript values
        let count = vadcopInfo.proofValuesMap.reduce((acc, item) => acc + (item.stage === 1 ? 1 : 0), 0);
        const used_vals = (this.hCnt < Math.ceil((vadcopInfo.nPublics + count + 10*vadcopInfo.aggTypes.length) / 8)) ? 4 : 3;
        if (used_vals < 12) {
            this.code.push(`for (var i = ${used_vals}; i < 12; i++) {`);
            this.code.push(`    _ <== ${signalName}_${this.hCnt-1}[i]; // Unused transcript values`);
            this.code.push(`}\n`);
        } 

        for (let i=0; i<12; i++) {
            this.out[i] = `${signalName}_${this.hCnt-1}[${i}]`;
        }

        for (let i=0; i<4; i++) {
            this.state[i] = `${signalName}_${this.hCnt-1}[${i}]`;
        } 

        this.pending = [];
        this.hiCnt = 0;
    }

    getFields1() {
        if (this.out.length == 0) {
            while (this.pending.length<8) {
                this.pending.push("0");
            }
            this.updateState();
        }
        const res = this.out.shift();
        this.hiCnt++;
        return res;
    }

    put(a, l, m) {
        if (typeof l !== "undefined") {
            if (typeof m !== "undefined") {
                for (let i=0; i<l; i++) {
                    for (let j=0; j<m; j++) {
                        this._add1(`${a}[${i}][${j}]`);
                    }
                }
            } else {
                for (let i=0; i<l; i++) {
                    this._add1(`${a}[${i}]`);
                }
            }
        } else {
            this._add1(a);
        }
    }

    _add1(a) {
        this.out = [];
        this.pending.push(a);
        if (this.pending.length == 8) {
            this.updateState();
        }
    }

    getCode() {
        for (let i=this.lastCodePrinted; i<this.code.length; i++) this.code[i] = "    "+this.code[i];
        let code = this.code.slice(this.lastCodePrinted, this.code.length).join("\n");
        this.lastCodePrinted = this.code.length;
        return code;
    }
}
-%>

template VerifyGlobalChallenges() {

<%  if(vadcopInfo.nPublics > 0) { -%>
    signal input publics[<%- vadcopInfo.nPublics %>];
<%  } -%>
<%  if(vadcopInfo.proofValuesMap.length > 0) { -%>
    signal input proofValues[<%- vadcopInfo.proofValuesMap.length %>][3];
<%  } -%>
    signal input stage1HashToEC[<%- vadcopInfo.aggTypes.length %>][2][5];
    
    signal input globalChallenge[3];
    signal calculatedGlobalChallenge[3];

<%   let transcript = new Transcript(); -%>
<%   if(vadcopInfo.nPublics > 0) transcript.put("publics", vadcopInfo.nPublics); -%>
<%   for(let j=0; j < vadcopInfo.proofValuesMap.length; j++) { -%>
<%      if(vadcopInfo.proofValuesMap[j].stage == 1) { -%>
<%          transcript.put(`proofValues[${j}]`, 1); -%>
<%      } else { -%>
    _ <== proofValues[<%- j %>]; // Unused proof values at stage 1
<%       } -%>
<%  }
    for(let k = 0; k < vadcopInfo.aggTypes.length; k++) {
        transcript.put("stage1HashToEC[" + k + "]", 2, 5);
    }
    transcript.getField("calculatedGlobalChallenge"); -%>
<%- transcript.getCode() %>

    globalChallenge === calculatedGlobalChallenge;
}
