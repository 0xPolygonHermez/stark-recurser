<%
class Transcript {
    constructor(name) {
        this.state = ["0", "0", "0", "0"];
        this.pending = [];
        this.out = [];
        this.hCnt = 0;
        this.lastCodePrinted = 0;
        this.name = name;

        this.code = [];
    }

    getState(v, l) {
        let curveConstants = vadcopInfo.curveConstants;
        this.code.push(`signal x[${l}] <== [${this.getFields1()}, ${this.getFields1()}, ${this.getFields1()}, ${this.getFields1()}, ${this.getFields1()}];`);
        this.code.push(`signal y[${l}] <== [${this.getFields1()}, ${this.getFields1()}, ${this.getFields1()}, ${this.getFields1()}, ${this.getFields1()}];\n`);
        this.code.push(`// Constants for the ${vadcopInfo.curve} curve`);
        this.code.push(`var A[5] = [${curveConstants.A}];`);
        this.code.push(`var B[5] = [${curveConstants.B}];`);
        this.code.push(`var Z[5] = [${curveConstants.Z}];`);
        this.code.push(`var C1[5] = [${curveConstants.C1}];`);
        this.code.push(`var C2[5] = [${curveConstants.C2}];`);
        this.code.push(`${v} <== HashToCurve(A, B, Z, C1, C2)(x,y);`);    
    }

    updateState()  {
        let signalName = "transcriptHash";
        if (this.name) signalName += "_" + this.name;
        this.code.push(`signal ${signalName}_${this.hCnt++}[12] <== Poseidon2(12)([${this.pending.join(',')}], [${this.state.join(',')}]);`);

        // Add unused transcript values
        let count = starkInfo.airValuesMap.reduce((acc, item) => acc + (item.stage === 1 ? 1 : 0), 0);
        const used_vals = (this.hCnt < Math.ceil(count / 8) + 1) ? 4 : 10;
        if (used_vals < 12) {
            this.code.push(`for (var i = ${used_vals}; i < 12; i++) {`);
            this.code.push(`    _ <== ${signalName}_${this.hCnt-1}[i]; // Unused transcript values`);
            this.code.push(`}\n`);
        } 

        for (let i=0; i<12; i++) {
            this.out[i] = `${signalName}_${this.hCnt-1}[${i}]`;
        }
        for (let i=0; i<4; i++) {
            this.state[i] = `${signalName}_${this.hCnt-1}[${i}]`;
        } 
        this.pending = [];
    }

    getFields1() {
        if (this.out.length == 0) {
            while (this.pending.length<8) {
                this.pending.push("0");
            }
            this.updateState();
        }
        return this.out.shift();
    }

    put(a, l) {
        if (typeof l !== "undefined") {
            for (let i=0; i<l; i++) {
                this._add1(`${a}[${i}]`);
            }
        } else {
            this._add1(a);
        }
    }

    _add1(a) {
        this.out = [];
        this.pending.push(a);
        if (this.pending.length == 8) {
            this.updateState();
        }
    }

    getCode() {
        for (let i=this.lastCodePrinted; i<this.code.length; i++) this.code[i] = "    "+this.code[i];
        let code = this.code.slice(this.lastCodePrinted, this.code.length).join("\n");
        this.lastCodePrinted = this.code.length;
        return code;
    }
}
-%>

template CalculateStage1HashToEC() {
    signal input rootC[4];
    signal input root1[4];

<%  if(starkInfo.airValuesMap.filter(a => a.stage == 1).length > 0) { -%>
    signal input airValues[<%- starkInfo.airValuesMap.length %>][3];
<%  } -%>

    signal output P[2][5];

<%  const transcriptStage = new Transcript(); -%>
<%  transcriptStage.put("rootC", 4); -%>
<%  transcriptStage.put("root1", 4); -%>
<%    for (let j=0; j<starkInfo.airValuesMap.length; j++) { -%>
<%        if(starkInfo.airValuesMap[j].stage == 1) { -%>
<%            transcriptStage.put(`airValues[${j}]`, 1); -%>
<%        } else { -%>
    _ <== airValues[<%- j %>]; // Unused air values at stage 1
<%        } -%>
<%    } -%>

<%    transcriptStage.getState("P", 5); -%>
<%-     transcriptStage.getCode(); %>
}
