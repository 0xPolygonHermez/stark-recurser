pragma circom 2.1.0;
pragma custom_templates;

<% function unrollCode(code) {                                                          -%>
<%
    function ref(r) {
        if (r.type == "eval") {
            return "evals[" + r.id + "]";
        } else if (r.type == "challenge") {
            if(r.stage === qStage) {
                return "challengeQ";
            } else if(r.stage === evalsStage) {
                return "challengeXi";
            } else if(r.stage === friStage) {
                return "challengesFRI[" + r.stageId + "]";
            } else {
                return "challengesStage" + r.stage + "[" + r.stageId + "]";
            }
        } else if (r.type == "public") {
            return "publics[" + r.id + "]";
        } else if (r.type == "x") {
            return "challengeXi";
        } else if (r.type == "Zi") {
            const boundary = starkInfo.boundaries[r.boundaryId];
            if(boundary.name === "everyRow") {
                return "Zh";
            } else if(boundary.name === "firstRow") {
                return "Zfirst";
            } else if(boundary.name === "lastRow") {
                return "Zlast";
            } else if(boundary.name === "everyFrame") {
                const boundaryId = starkInfo.boundaries.filter(b=>b.name === "everyFrame").findIndex(b => b.offsetMin === boundary.offsetMin && b.offsetMax === boundary.offsetMax);
                return "Zframe" + boundaryId + "[" + (boundary.offsetMin + boundary.offsetMax - 1) + "]";
            } else throw new Error("Invalid boundary: " + r.boundaryId);
        } else if (r.type == "xDivXSubXi") {
            return "xDivXSubXi[" + r.id + "]";
        } else if (r.type == "tmp") {
            return "tmp_"+r.id;
        } else if (r.type == "cm") {
            const pol = starkInfo.cmPolsMap[r.id];
            return "mapValues." + r.type + pol.stage + "_" + pol.stageId;
        } else if (r.type == "custom") {
            const pol = starkInfo.customCommitsMap[r.commitId][r.id];
            return "mapValues." + r.type + "_" + starkInfo.customCommits[r.commitId].name + "_" + pol.stage + "_" + pol.stageId;
        } else if (r.type == "const") {
            return "consts[" + r.id + "]";
        } else if (r.type == "number") {
            return r.value;
        } else if (r.type === "airgroupvalue") {
            return "airgroupValues[" + r.id + "]";
        } else if (r.type === "airvalue") {
            if(r.dim == 1) {
                return "airvalues[" + r.id + "][0]";
            }
            return "airvalues[" + r.id + "]";
        } else if (r.type === "proofvalue") {
            if(r.dim == 1) {
                return "proofvalues[" + r.id + "][0]";
            }
            return "proofvalues[" + r.id + "]";
        } else {
            throw new Error("Invalid Ref: " +r.type);
        }
    }
-%>
<% for(let i=0; i<code.length; i++) {                                 -%>
<%      let inst = code[i];                                           -%>
<%      if (inst.dest.type == "tmp" && ![1,3].includes(inst.dest.dim)) {                -%>
<%          throw new Error("Invalid dimension");                                       -%>
<%      }                                                                               -%>
<%      if(inst.src[0] && ["Zi", "airgroupvalue"].includes(inst.src[0].type)) inst.src[0].dim = 3;               -%>
<%      if(inst.src[1] && ["Zi", "airgroupvalue"].includes(inst.src[1].type)) inst.src[1].dim = 3;               -%>
<%      if (inst.op == "add") {                                                         -%>
<%          if ((inst.src[0].dim==1) && (inst.src[1].dim==1)) {                         -%>
    signal <%- ref(inst.dest) %> <== <%- ref(inst.src[0]) %> + <%- ref(inst.src[1]) %>;
<%          } else if ((inst.src[0].dim==1) && (inst.src[1].dim==3)) {                  -%>
    signal <%- ref(inst.dest) %>[3] <== [<%- ref(inst.src[0]) %> + <%- ref(inst.src[1]) %>[0], <%- ref(inst.src[1]) %>[1],  <%- ref(inst.src[1]) %>[2]];
<%          } else if ((inst.src[0].dim==3) && (inst.src[1].dim==1)) {                  -%>
    signal <%- ref(inst.dest) %>[3] <== [<%- ref(inst.src[0]) %>[0] + <%- ref(inst.src[1]) %>, <%- ref(inst.src[0]) %>[1], <%- ref(inst.src[0]) %>[2]];
<%          } else if ((inst.src[0].dim==3) && (inst.src[1].dim==3)) {                  -%>
    signal <%- ref(inst.dest) %>[3] <== [<%- ref(inst.src[0]) %>[0] + <%- ref(inst.src[1]) %>[0], <%- ref(inst.src[0]) %>[1] + <%- ref(inst.src[1]) %>[1], <%- ref(inst.src[0]) %>[2] + <%- ref(inst.src[1]) %>[2]];
<%          } else throw new Error("Invalid src dimensions");                          -%>
<%      } else if (inst.op == "sub") {                                                  -%>
<%          if ((inst.src[0].dim==1) && (inst.src[1].dim==1)) {                         -%>
    signal <%- ref(inst.dest) %> <== <%- ref(inst.src[0]) %> - <%- ref(inst.src[1]) %>;
<%          } else if ((inst.src[0].dim==1) && (inst.src[1].dim==3)) {                  -%>
    signal <%- ref(inst.dest) %>[3] <== [<%- ref(inst.src[0]) %> - <%- ref(inst.src[1]) %>[0], -<%- ref(inst.src[1]) %>[1], -<%- ref(inst.src[1]) %>[2]];
<%          } else if ((inst.src[0].dim==3) && (inst.src[1].dim==1)) {                  -%>
    signal <%- ref(inst.dest) %>[3] <== [<%- ref(inst.src[0]) %>[0] - <%- ref(inst.src[1]) %>, <%- ref(inst.src[0]) %>[1], <%- ref(inst.src[0]) %>[2]];
<%          } else if ((inst.src[0].dim==3) && (inst.src[1].dim==3)) {                  -%>
    signal <%- ref(inst.dest) %>[3] <== [<%- ref(inst.src[0]) %>[0] - <%- ref(inst.src[1]) %>[0], <%- ref(inst.src[0]) %>[1] - <%- ref(inst.src[1]) %>[1], <%- ref(inst.src[0]) %>[2] - <%- ref(inst.src[1]) %>[2]];
<%          } else throw new Error("Invalid src dimensions");                          -%>
<%      } else if (inst.op == "mul") {                                                  -%>
<%          if ((inst.src[0].dim==1) && (inst.src[1].dim==1)) {                         -%>
    signal <%- ref(inst.dest) %> <== <%- ref(inst.src[0]) %> * <%- ref(inst.src[1]) %>;
<%          } else if ((inst.src[0].dim==1) && (inst.src[1].dim==3)) {                  -%>
    signal <%- ref(inst.dest) %>[3] <== [<%- ref(inst.src[0]) %> * <%- ref(inst.src[1]) %>[0], <%- ref(inst.src[0]) %> * <%- ref(inst.src[1]) %>[1], <%- ref(inst.src[0]) %> * <%- ref(inst.src[1]) %>[2]];
<%          } else if ((inst.src[0].dim==3) && (inst.src[1].dim==1)) {                  -%>
    signal <%- ref(inst.dest) %>[3] <== [<%- ref(inst.src[0]) %>[0] * <%- ref(inst.src[1]) %>, <%- ref(inst.src[0]) %>[1] * <%- ref(inst.src[1]) %>, <%- ref(inst.src[0]) %>[2] * <%- ref(inst.src[1]) %>];
<%          } else if ((inst.src[0].dim==3) && (inst.src[1].dim==3)) {                  -%>
    signal <%- ref(inst.dest) %>[3] <== CMul()(<%- ref(inst.src[0]) %>, <%- ref(inst.src[1]) %>);
<%          } else throw new Error("Invalid src dimensions");                              -%>
<%      } else if (inst.op == "copy") {                                                 -%>
<%          if (inst.src[0].dim==1) {                                                   -%>
    signal <%- ref(inst.dest) %> <== <%- ref(inst.src[0]) %>;
<%          } else if (inst.src[0].dim==3) {                                            -%>
    signal <%- ref(inst.dest) %>[3] <== <%- ref(inst.src[0]) %>;
<%          } else throw new Error("Invalid src dimensions");                          -%>
<%      } else throw new Error("Invalid op");                                           -%>
<% }                                                                                    -%>
<% return ref(code[code.length-1].dest);                                                -%>
<% }                                                                                    -%>
-%>
<%  const NFields = Math.floor(((starkInfo.starkStruct.nQueries *  starkInfo.starkStruct.steps[0].nBits) - 1)/63)+1; -%>
<%
class Transcript {
    constructor(name) {
        this.state = ["0", "0", "0", "0"];
        this.pending = [];
        this.out = [];
        this.stCnt =0;
        this.hCnt =0;
        this.hiCnt =0;
        this.n2bCnt =0;
        this.lastCodePrinted = 0;
        this.name = name;

        this.code = [];
    }


    getField(v) {
        this.code.push(`${v} <== [${this.getFields1()}, ${this.getFields1()}, ${this.getFields1()}];`);
    }

    getState(v) {
        this.code.push(`${v} <== [${this.getFields1()}, ${this.getFields1()}, ${this.getFields1()}, ${this.getFields1()}];`);    
    }

    updateState()  {
        let signalName = "hash";
        if(this.name) signalName += "_" + this.name;
        if(this.hCnt > 0) {
            const firstUnused = Math.max(this.hiCnt, 4);
            if(firstUnused < 12) {
                this.code.push(`for(var i = ${firstUnused}; i < 12; i++){
        _ <== ${signalName}_${this.hCnt -1}[i]; // Unused hash values 
    }`)
            }  
        }
        this.code.push(`\n    signal ${signalName}_${this.hCnt++}[12] <== Poseidon(12)([${this.pending.join(',')}], [${this.state.join(',')}]);`);
        for (let i=0; i<12; i++) {
            this.out[i] = `${signalName}_${this.hCnt-1}[${i}]`;
        }
        for (let i=0; i<4; i++) {
            this.state[i] = `${signalName}_${this.hCnt-1}[${i}]`;
        } 
        this.pending = [];
        this.hiCnt = 0;
    }

    getFields1() {
        if (this.out.length == 0) {
            while (this.pending.length<8) {
                this.pending.push("0");
            }
            this.updateState();
        }
        const res = this.out.shift();
        this.hiCnt++;
        return res;
    }

    put(a, l) {
        if (typeof l !== "undefined") {
            for (let i=0; i<l; i++) {
                this._add1(`${a}[${i}]`);
            }
        } else {
            this._add1(a);
        }
    }

    _add1(a) {
        this.out = [];
        this.pending.push(a);
        if (this.pending.length == 8) {
            this.updateState();
        }
    }

    getPermutations(v, n, nBits) {
        let signalName = "hash";
        if(this.name) signalName += "_" + this.name;
        const totalBits = n*nBits;
        const n2b = [];
        for (let i=0; i<NFields; i++) {
            const f = this.getFields1();
            n2b[i] = `hashN2b_${this.n2bCnt++}`;
            this.code.push(`signal {binary} ${n2b[i]}[64] <== Num2Bits_strict()(${f});`);
        }
        if(this.hiCnt < 12) {
            this.code.push(`for(var i = ${this.hiCnt}; i < 12; i++){
        _ <== ${signalName}_${this.hCnt - 1}[i]; // Unused hash values        
    }\n`)
        }
        this.code.push(`// From each partial hash converted to bits, we assign those bits to queriesFRI[q] to define the query positions`)
        this.code.push(`var q = 0; // Query number `)
        this.code.push(`var b = 0; // Bit number `)
        for(let i = 0; i<NFields; i++) {
            const nBits = i + 1 == NFields ? totalBits - 63*i : 63;
            this.code.push(`for (var j = 0; j < ${nBits}; j++) {
        ${v}[q][b] <== ${n2b[i]}[j];
        b++;
        if (b == ${starkStruct.steps[0].nBits}) {
            b = 0; 
            q++;
        }
    }`);
            if(nBits === 63) {
                this.code.push(`_ <== ${n2b[i]}[63]; // Unused bit\n`); 
            } else {
                this.code.push(`for (var j = ${nBits}; j < 64; j++) {
        _ <== ${n2b[i]}[j]; // Unused bits        
    }`);
            }
        }
    }

    getCode() {
        for (let i=this.lastCodePrinted; i<this.code.length; i++) this.code[i] = "    "+this.code[i];
        let code = this.code.slice(this.lastCodePrinted, this.code.length).join("\n");
        this.lastCodePrinted = this.code.length;
        return code;
    }
}
-%>
-%>
include "cmul.circom";
include "cinv.circom";
include "poseidon.circom";
include "bitify.circom";
include "fft.circom";
include "fri.circom";
include "evalpol.circom";
include "treeselector4.circom";
<% if(starkStruct.splitLinearHash) { -%>
include "merklehash_gpu.circom";
<% } else { -%>
include "merklehash.circom";
<% } -%>
<% let airgroupId; -%>
<% if(starkInfo.airgroupId !== undefined) { -%>
<%      airgroupId = starkInfo.airgroupId; -%>
<% } -%>
-%>
<% let qStage = starkInfo.nStages + 1; -%>
<% let evalsStage = starkInfo.nStages + 2; -%>
<% let friStage = starkInfo.nStages + 3; -%>

/* 
    Calculate FRI queries from a field element
*/
<% let calculateFriQueriesName = "calculateFRIQueries"; -%>
<% if(airgroupId !== undefined) { -%>
<%      calculateFriQueriesName += airgroupId; -%>
<% } -%>
template <%- calculateFriQueriesName %>() {
    signal input fieldElement[3];

    signal output {binary} queriesFRI[<%- starkStruct.nQueries %>][<%- starkStruct.steps[0].nBits %>];
-%>
<%  const transcriptQueries = new Transcript("friQueries"); -%>
<%  transcriptQueries.put("fieldElement", 3); -%>
-%>
<% transcriptQueries.getPermutations("queriesFRI", starkStruct.nQueries, starkStruct.steps[0].nBits); -%>
<%- transcriptQueries.getCode(); %>
}

/* 
    Calculate the proof challenges from the proof elements
*/ 
<% let calculateChallengesName = "calculateChallenges"; -%>
<% if(airgroupId !== undefined) { -%>
<%      calculateChallengesName += airgroupId; -%>
<% } -%>
<% if (!options.inputChallenges) { -%>
template <%- calculateChallengesName %>() {
-%>
<%  if(starkInfo.nPublics > 0) { -%>
    signal input publics[<%- starkInfo.nPublics %>];
<%  } -%>

    signal input rootC[4];

<% for(let i=0; i < starkInfo.nStages; i++) {  -%>
<%  const stage = i + 1; -%>
    signal input root<%- stage %>[4];
<% } -%>
    signal input root<%- qStage %>[4];

    signal input evals[<%- starkInfo.evMap.length %>][3];

<% for (let s=1; s<starkStruct.steps.length; s++) {   -%>
    signal input s<%- s %>_root[4];
<% }                                                     -%>
    signal input finalPol[<%- 1 << starkStruct.steps[starkStruct.steps.length-1].nBits %>][3];
    
<%  for(let i = 0; i < starkInfo.nStages; ++i) { -%>
<%  if(starkInfo.challengesMap.filter(c => c.stage === i + 1).length === 0) continue; -%>
    signal output challengesStage<%- i + 1 %>[<%- starkInfo.challengesMap.filter(c => c.stage === i + 1).length %>][3];
<%  } -%>
    signal output challengeQ[3];
    signal output challengeXi[3];
    signal output challengesFRI[2][3];
    signal output challengesFRISteps[<%- starkStruct.steps.length + 1 %>][3];
    signal output {binary} queriesFRI[<%- starkStruct.nQueries %>][<%- starkStruct.steps[0].nBits %>];

<%  if(starkInfo.starkStruct.hashCommits) { -%>
    // Intermediate hashes
<%  if(starkInfo.nPublics > 0) { -%>
    signal publicsHash[4];
<%  } -%>
    signal evalsHash[4];
    signal lastPolFRIHash[4];
<%  } -%>
-%>
<%   const transcript = new Transcript(); -%>
<%   transcript.put("rootC", 4  ); -%>
<%  if(starkInfo.nPublics > 0) { -%>
<%   if(!starkInfo.starkStruct.hashCommits) { -%>
<%         transcript.put("publics", starkInfo.nPublics); -%>
<%   } else { -%>
<%-      transcript.getCode(); %>
<%      const transcriptPublics = new Transcript("publics");
        transcriptPublics.put("publics", starkInfo.nPublics);
        transcriptPublics.getState("publicsHash"); -%>
<%-      transcriptPublics.getCode(); %>
<%      transcript.put("publicsHash", 4); -%>
<%  } -%>
<%  } -%>
-%>
<%   for(let i=0; i < starkInfo.nStages; i++) {
        const stage = i + 1;
        for(let j = 0; j < starkInfo.challengesMap.filter(c => c.stage === stage).length; ++j) {
            transcript.getField("challengesStage" + stage + "[" + j + "]", 3);
        }
        transcript.put("root" + stage, 4);
    }    
    
    transcript.getField("challengeQ", 3);
    transcript.put(`root${qStage}`, 4);

    transcript.getField("challengeXi", 3); -%>
<%   if(!starkInfo.starkStruct.hashCommits) { -%>
<%      for (let i=0; i<starkInfo.evMap.length; i++) {
            transcript.put(`evals[${i}]`, 3);
        } -%>
<%   } else { -%>
<%-      transcript.getCode(); %>
<%      const transcriptEvals = new Transcript("evals");
        for (let i=0; i<starkInfo.evMap.length; i++) {
            transcriptEvals.put(`evals[${i}]`, 3);
        }
        transcriptEvals.getState("evalsHash"); -%>
<%-      transcriptEvals.getCode(); %>
<%      transcript.put("evalsHash", 4); -%>
<%  } -%>
    
<%  transcript.getField("challengesFRI[0]", 3);
    transcript.getField("challengesFRI[1]", 3); -%>
<%  for (let si=0; si<starkStruct.steps.length; si++) { -%>
<%      transcript.getField(`challengesFRISteps[${si}]`, 3); -%>
<%      if (si < starkStruct.steps.length-1) { -%>
<%          transcript.put(`s${si+1}_root`, 4); -%>
<%        } else { -%>
<%          if(!starkInfo.starkStruct.hashCommits) { -%>
<%              for (let j=0; j< 1<<starkStruct.steps[starkStruct.steps.length-1].nBits; j++ ) {
                    transcript.put(`finalPol[${j}]`, 3);
                } -%>
<%          } else { -%>
<%-             transcript.getCode(); %>
<%              const transcriptLastPolFRI = new Transcript("lastPolFRI");
                for (let j=0; j< 1<<starkStruct.steps[starkStruct.steps.length-1].nBits; j++ ) {
                    transcriptLastPolFRI.put(`finalPol[${j}]`, 3);
                }
                transcriptLastPolFRI.getState("lastPolFRIHash"); -%>
<%-              transcriptLastPolFRI.getCode(); %>
<%              transcript.put("lastPolFRIHash", 4); -%>
<%          } -%>
<%      } -%>
<%  } -%>

<%  transcript.getField(`challengesFRISteps[${starkStruct.steps.length}]`, 3); -%>
<%- transcript.getCode() %>

    queriesFRI <== <%- calculateFriQueriesName %>()(challengesFRISteps[<%- starkStruct.steps.length %>]);
}
<% } -%>

/* 
    Run the consistency check around the out-of-domain sample
*/
-%>
<% let verifyEvaluationsName = "VerifyEvaluations"; -%>
<% if(airgroupId !== undefined) { -%>
<%      verifyEvaluationsName += airgroupId; -%>
<% } -%>
template <%- verifyEvaluationsName %>() {
    // Signal used to enable or disable the constraints
    signal input {binary} enable;

<%  if(starkInfo.nPublics > 0) { -%>
    signal input publics[<%- starkInfo.nPublics %>];
<%  } -%>
-%>
<%  if(starkInfo.airValuesMap.length > 0) { -%>
    signal input airvalues[<%- starkInfo.airValuesMap.length %>][3];
<%  } -%>
<%  if(starkInfo.airgroupValuesMap.length > 0) { -%>
    signal input airgroupValues[<%- starkInfo.airgroupValuesMap.length %>][3];
<%  } -%>
<%  if(starkInfo.proofValuesMap.length > 0) { -%>
    signal input proofvalues[<%- starkInfo.proofValuesMap.length %>][3];
<%  } -%>

<%  for(let i = 0; i < starkInfo.nStages; ++i) { -%>
<%  const stage = i + 1; -%>
<%  if(starkInfo.challengesMap.filter(c => c.stage === stage).length === 0) continue; -%>
    signal input challengesStage<%- stage %>[<%- starkInfo.challengesMap.filter(c => c.stage === stage).length -%>][3];
<%  } -%>
    signal input challengeQ[3];
    signal input challengeXi[3];

    signal input evals[<%- starkInfo.evMap.length %>][3];

    // Compute all powers of z (stored in challengeXi) up to nBits, i.e, [z, z^2, ..., z^nBits]
    signal zMul[<%- starkStruct.nBits %>][3];
    for (var i = 0; i < <%- starkStruct.nBits %> ; i++) {
        if (i == 0){
            zMul[i] <== CMul()(challengeXi, challengeXi);
        } else {
            zMul[i] <== CMul()(zMul[i-1], zMul[i-1]);
        }
    }

    // Compute the evaluation of the vanishing polynomial Zh(X) = X^nBits - 1 at z
    signal Z[3] <== [zMul[<%- starkStruct.nBits - 1%>][0] - 1, zMul[<%- starkStruct.nBits - 1%>][1], zMul[<%- starkStruct.nBits - 1%>][2]];
    signal Zh[3] <== CInv()(Z);
-%>
<%  if(starkInfo.boundaries.map(b => b.name).includes("firstRow")) { -%>
    // Compute the evaluation of the polynomial Zfirst(X) = X - 1 at z
    signal Zfirst[3] <== CInv()([challengeXi[0] - 1, challengeXi[1], challengeXi[2]]);
<%  } -%>
-%>
<%  if(starkInfo.boundaries.map(b => b.name).includes("lastRow")) { -%>
<%  let root = F.one; -%>
<%  for(let i = 0; i < (1 << starkStruct.nBits) - 1; ++i) { -%>
<%    root = F.mul(root, F.w[starkStruct.nBits]); -%>
<%  } -%>
    // Compute the evaluation of the polynomial Zlast(X) = X - root^(nBits-1) at z
    signal Zlast[3] <== CInv()([challengeXi[0] - <%- root %>, challengeXi[1], challengeXi[2]]);
<%  } -%>
-%>
<%  if(starkInfo.boundaries.map(b => b.name).includes("everyFrame")) { -%>
<%  const constraintFrames = starkInfo.boundaries.filter(b => b.name === "everyFrame"); -%>
<%  for(let i = 0; i < constraintFrames.length; ++i) { -%>
<%      let frame = constraintFrames[i]; -%>
<%      let c = 0; -%>
    signal Zframe<%- i %>[<%- frame.offsetMin + frame.offsetMax %>][3];
<%      for(let j = 0; j < frame.offsetMin; j++) { -%>
<%          let root = F.one; -%>
<%          for(let k = 0; k < j; ++k) { -%>
<%              root = F.mul(root, F.w[starkStruct.nBits]); -%>
<%          } -%>
<%          if(c === 0) { -%> 
    Zframe<%- i %>[<%- c++ %>] <== CMul()(Zh, [challengeXi[0] - <%- root %>, challengeXi[1], challengeXi[2]]);
<%          } else { -%>
    Zframe<%- i %>[<%- c++ %>] <== CMul()(Zframe<%- i %>, [challengeXi[0] - <%- root %>, challengeXi[1], challengeXi[2]]);
<%          } -%>
<%      } -%>
<%      for(let j = 0; j < frame.offsetMax; j++) { -%>
<%          let root = F.one; -%>
<%          for(let k = 0; k < ((1<<starkStruct.nBits) - i - 1); ++k) { -%>
<%              root = F.mul(root, F.w[starkStruct.nBits]); -%>
<%          } -%>
<%          if(c === 0) { -%> 
    Zframe<%- i %>[<%- c++ %>] <== CMul()(Zh, [challengeXi[0] - <%- root %>, challengeXi[1], challengeXi[2]]);
<%          } else { -%>
    Zframe<%- i %>[<%- c++ %>] <== CMul()(Zframe<%- i %>, [challengeXi[0] - <%- root %>, challengeXi[1], challengeXi[2]]);
<%          } -%>
<%      } -%>
<%  } -%>
<%  } -%>

    // Given the public inputs, the challenges, the evaluations and the one-dimensional elements,
    // compute the evaluation of the RLC:
    //      q_0(X) + challenge * q_1(X) + challenge^2 * q_2(X) + ... + challenge^(l-1) * q_l-1(X) 
    // at z. This is the RHS of equation (30) in https://eprint.iacr.org/2023/474.pdf.
<% const evalP = unrollCode(verifierInfo.qVerifier.code) -%>

    // Next, we compute the evaluation of the expression:
    //      Q1(X) + X^n*Q2(X) + X^(2路n)*Q3(X) + ... X^((qDeg-1)路n)*Q(X) 
    // at z, where each Q_i(X) is a polynomial of degree < n. This is the LHS of equation (30) in https://eprint.iacr.org/2023/474.pdf.
    signal xAcc[<%- starkInfo.qDeg %>][3]; // Stores X^i evaluated at z
    signal qStep[<%- starkInfo.qDeg-1 %>][3]; // Stores the evaluations of Q_i
    signal qAcc[<%- starkInfo.qDeg %>][3]; // Stores the accumulate sum of Q_i
    for (var i = 0; i < <%- starkInfo.qDeg %>; i++) {
<%      let qIndex = starkInfo.cmPolsMap.findIndex(p => p.stage === qStage && p.stageId === 0); -%>
<%      const evId = starkInfo.evMap.findIndex(e => e.type === "cm" && e.id === qIndex); -%>
        if (i == 0) {
            xAcc[0] <== [1, 0, 0];
            qAcc[0] <== evals[<%- evId %>+i];
        } else {
            xAcc[i] <== CMul()(xAcc[i-1], zMul[<%- starkStruct.nBits - 1%>]);
            qStep[i-1] <== CMul()(xAcc[i], evals[<%- evId %>+i]);
            qAcc[i][0] <== qAcc[i-1][0] + qStep[i-1][0];
            qAcc[i][1] <== qAcc[i-1][1] + qStep[i-1][1];
            qAcc[i][2] <== qAcc[i-1][2] + qStep[i-1][2];
        }
    }

    // Finally, check that the LHS is equal to the RHS evaluated at z:
    //      Q1(z) + z^n*Q2(z) + z^(2路n)*Q3(z) + ... z^((qDeg-1)路n)*Q(z) = q_0(z) + challenge * q_1(z) + challenge^2 * q_2(z) + ... + challenge^(l-1) * q_l-1(z)
    enable * (<%- evalP %>[0] - qAcc[<%- starkInfo.qDeg-1 %>][0]) === 0;
    enable * (<%- evalP %>[1] - qAcc[<%- starkInfo.qDeg-1 %>][1]) === 0;
    enable * (<%- evalP %>[2] - qAcc[<%- starkInfo.qDeg-1 %>][2]) === 0;
}

/* 
    Calculate the value of the FRI polynomial at the query point
*/
<% let calculateFRIPolName = "CalculateFRIPolValue"; -%>
<% if(airgroupId !== undefined) { -%>
<%      calculateFRIPolName += airgroupId; -%>
<% } -%>
template <%- calculateFRIPolName %>() {
    signal input {binary} queryFRI[<%- starkStruct.steps[0].nBits %>];

    signal input challengeXi[3];
    signal input challengesFRI[2][3];

    // Evaluations around the out-of-domain sample
    signal input evals[<%- starkInfo.evMap.length %>][3];

    // Evaluations of the constant polynomials at the query point
    signal input consts[<%- starkInfo.nConstants %>];

<%  for(let i = 0; i < starkInfo.customCommits.length; ++i) { -%>
    // Evaluations of the custom <%- starkInfo.customCommits[i].name %> polynomials at the query point
    signal input custom_<%- starkInfo.customCommits[i].name %>_0[<%- starkInfo.mapSectionsN[`${starkInfo.customCommits[i].name}0`] %>];
<%  } -%>

    // Evaluations of the committed polynomials at the query point
<% for(let i = 0; i < starkInfo.nStages; ++i) { -%>
<%  const stage = i + 1; -%>
<%  if(starkInfo.mapSectionsN[`cm${stage}`] > 0) { -%> 
    signal input cm<%- stage %>[<%- starkInfo.mapSectionsN[`cm${stage}`] %>];
<%  } -%>
<% } -%>
    signal input cm<%- qStage %>[<%- starkInfo.mapSectionsN[`cm${qStage}`]  %>];
    
    signal output queryVals[3];

<% let mapValuesName = "MapValues"; -%>
<% if(airgroupId !== undefined) { -%>
<%      mapValuesName += airgroupId; -%>
<% } -%>
    // Map the s0_vals so that they are converted either into single vars (if they belong to base field) or arrays of 3 elements (if 
    // they belong to the extended field). 
    component mapValues = <%- mapValuesName %>();
<% for(let i = 0; i < starkInfo.nStages; ++i) { -%>
<%  const stage = i + 1; -%>
<%  if(starkInfo.mapSectionsN[`cm${stage}`] > 0) { -%> 
    mapValues.vals<%- stage %> <== cm<%- stage %>;
<%  } -%>
<% } -%>
    mapValues.vals<%- qStage %> <== cm<%- qStage %>;
<% for(let i = 0; i < starkInfo.customCommits.length; ++i) { -%>
    mapValues.vals_<%- starkInfo.customCommits[i].name %>_0 <== custom_<%- starkInfo.customCommits[i].name %>_0;
<%  } -%>

    signal xacc[<%- starkStruct.steps[0].nBits %>];
    xacc[0] <== queryFRI[0]*(<%- F.shift %>*roots(<%- starkStruct.steps[0].nBits %>) - <%- F.shift %>) + <%- F.shift %>;
    for (var i = 1; i < <%- starkStruct.steps[0].nBits %>; i++) {
        xacc[i] <== xacc[i-1] * (queryFRI[i]*(roots(<%- starkStruct.steps[0].nBits %>-i) - 1) + 1);
    }

    // Compute the denominators of the opening domains
    signal xDivXSubXi[<%- starkInfo.openingPoints.length %>][3];
-%>
<%  for(var i=0; i<starkInfo.openingPoints.length; ++i) { -%>
<%  const opening = Number(starkInfo.openingPoints[i]); -%>
<%  let root = ""; -%>
<%  for(let j = 0; j < Math.abs(opening); ++j) {
        if (j === 0) {
            root += `${opening > 0 ? "roots" : "invroots"}(${starkStruct.nBits})`; 
        } else {
            root += ` * ${opening > 0 ? "roots" : "invroots"}(${starkStruct.nBits})`; 
        }
   } -%>
<%  if (Math.abs(opening) > 0) { -%>
    // X / (X - <%- root %>*Xi)
    signal den<%- i %>inv[3] <== CInv()([xacc[<%- starkStruct.steps[0].nBits-1 %>] - <%- root %> * challengeXi[0], - <%- root %> * challengeXi[1], - <%- root %> * challengeXi[2]]);
<%  } else { -%>
    // X / (X - Xi)
    signal den<%- i %>inv[3] <== CInv()([xacc[<%- starkStruct.steps[0].nBits-1 %>] - challengeXi[0], - challengeXi[1], - challengeXi[2]]);
<%  } -%>
    xDivXSubXi[<%- i %>] <== [xacc[<%- starkStruct.steps[0].nBits-1 %>] * den<%- i %>inv[0], xacc[<%- starkStruct.steps[0].nBits-1 %>] * den<%- i %>inv[1],  xacc[<%- starkStruct.steps[0].nBits-1 %>] * den<%- i %>inv[2]];
<%  } -%>

    // Compute the evaluations of the FRI polynomial at the query:
    //        sum_i (f_i(X) - f_i(Xi))/(X - Xi)
<% const evalQ = unrollCode(verifierInfo.queryVerifier.code) -%>

    queryVals[0] <== <%- evalQ %>[0];
    queryVals[1] <== <%- evalQ %>[1];
    queryVals[2] <== <%- evalQ %>[2];
}

/* 
    Performs the consistency check of the FRI polynomial around a domain sample:
    Given the evaluation of the FRI polynomial at the query point, verifies that another
    claimed value is the same
*/
<% let verifyQueryName = "VerifyQuery"; -%>
<% if(airgroupId !== undefined) { -%>
<%      verifyQueryName += airgroupId; -%>
<% } -%>
template <%- verifyQueryName %>(currStepBits, nextStepBits) {
    // Signal used to enable or disable the constraints
    signal input {binary} enable;

    signal input {binary} queryFRI[<%- starkStruct.steps[0].nBits %>];

    // Computed value of the FRI polynomial at the query point
    signal input queryVals[3];

    var nextStep = currStepBits - nextStepBits;
    // Claimed value
    signal input claimedValue[1 << nextStep][3];
    
    signal {binary} s0_keys_lowValues[nextStep];
    for (var i = 0; i < nextStep; i++) {
        s0_keys_lowValues[i] <== queryFRI[i + nextStepBits];
    }

    for (var i = 0; i < nextStepBits; i++) {
        _ <== queryFRI[i]; // Unused bits
    }
   
    signal lowValues[3] <== TreeSelector(nextStep, 3)(claimedValue, s0_keys_lowValues);

    enable * (lowValues[0] - queryVals[0]) === 0;
    enable * (lowValues[1] - queryVals[1]) === 0;
    enable * (lowValues[2] - queryVals[2]) === 0;
}

/* 
    Polynomials can either be defined over the base field (such as the initial polynomials constants and tr) or over the extended field
    (such as the grand product Z or the quotient Q).
    This function processes the values, which are stored in an array vals[n] and splits them in multiple signals of the base
    field size or the extended field size.
*/
template <%- mapValuesName %>() {
<% for(let i = 0; i < starkInfo.nStages; ++i) { -%>
<%  const stage = i + 1; -%>
<%  if(starkInfo.mapSectionsN[`cm${stage}`] > 0) { -%> 
    signal input vals<%- stage %>[<%- starkInfo.mapSectionsN[`cm${stage}`] %>];
<%  } -%>
<% } -%>
    signal input vals<%- qStage %>[<%- starkInfo.mapSectionsN[`cm${qStage}`]  %>];
<%  for(let i = 0; i < starkInfo.customCommits.length; ++i) { -%>
    signal input vals_<%- starkInfo.customCommits[i].name %>_0[<%- starkInfo.mapSectionsN[`${starkInfo.customCommits[i].name}0`] %>];
<%  } -%>
<% for (let t = 1; t<=starkInfo.nStages + 1; t++) {                              -%>
<%      let index = t;                       -%>
<%      let sectionsStage = starkInfo.cmPolsMap.filter(p => p.stage === t);  -%>
<%      for (let i=0; i< sectionsStage.length; i++) {         -%>
<%          const p = sectionsStage[i];  -%>
<%          if (p.dim == 1) {                                                    -%>
    signal output cm<%- t %>_<%- i %>;
<%          } else if (p.dim == 3) {                                             -%>
    signal output cm<%- t %>_<%- i %>[3];
<%          } else throw new Error("Invalid dim")                                -%>
<%      }                                                                        -%>
<% }                                                                             -%>
<% for (let t = 0; t < starkInfo.customCommits.length; ++t) { -%>
<%    for(let l = 0; l < starkInfo.customCommits[t].stageWidths.length; ++l) { -%>
<%        let sectionsStage = starkInfo.customCommitsMap[t].filter(p => p.stage === l);  -%>
<%        for (let i=0; i< sectionsStage.length; i++) {         -%>
<%        const p = sectionsStage[i];  -%>
<%            if (p.dim == 1) {                                                    -%>
    signal output custom_<%- starkInfo.customCommits[t].name%>_<%- l %>_<%- i %>;
<%            } else if (p.dim == 3) {                                             -%>
    signal output custom_<%- starkInfo.customCommits[t].name%>_<%- l %>_<%- i %>[3];
<%            } else throw new Error("Invalid dim")                                -%>
<%        } -%>
<%    } -%>
<% } -%>
-%>
<% for (let t = 0; t < starkInfo.customCommits.length; ++t) { -%>
<%    for(let l = 0; l < starkInfo.customCommits[t].stageWidths.length; ++l) { -%>
<%       let sectionsStage = starkInfo.customCommitsMap[t].filter(p => p.stage === l);  -%>
<%        for (let i=0; i< sectionsStage.length; i++) {         -%>
<%            const p = sectionsStage[i];  -%>
<%            if (p.dim == 1) {                                                    -%>
    custom_<%- starkInfo.customCommits[t].name%>_<%- l %>_<%- i %> <== vals_<%- starkInfo.customCommits[t].name %>_0[<%- p.stagePos %>];
<%            } else if (p.dim == 3) {                                             -%>
    custom_<%- starkInfo.customCommits[t].name%>_<%- l %>_<%- i %> <== [vals_<%- starkInfo.customCommits[t].name %>_0[<%- p.stagePos %>],vals_<%- starkInfo.customCommits[t].name %>_0[<%- p.stagePos + 1 %>] , vals_<%- starkInfo.customCommits[t].name %>_0[<%- p.stagePos + 2 %>]];
<%            } else throw new Error("Invalid dim")                                -%>
<%        } -%>
<%    } -%>
<% } -%>
-%>
<% for (let t = 1; t<=starkInfo.nStages + 1; t++) {                              -%>
<%      let sectionsStage = starkInfo.cmPolsMap.filter(p => p.stage === t);  -%>
<%      for (let i=0; i< sectionsStage.length; i++) {         -%>
<%          const p = sectionsStage[i];  -%>
<%          if (p.dim == 1) {                                                    -%>
    cm<%- t %>_<%- i %> <== vals<%- t %>[<%- p.stagePos %>];
<%          } else if (p.dim == 3) {                                             -%>
    cm<%- t %>_<%- i %> <== [vals<%- t %>[<%- p.stagePos %>],vals<%- t %>[<%- p.stagePos + 1 %>] , vals<%- t %>[<%- p.stagePos + 2 %>]];
<%          } else throw new Error("Invalid dim")                                -%>
<%      }                                                                        -%>
<% }                                                                             -%>
}

<% let verifierName = "StarkVerifier"; -%>
<% if(airgroupId !== undefined) { -%>
<%  verifierName += airgroupId; -%>
<% } -%>
/* 
    STARK verifier
*/
template <%- verifierName %>() {
    // Signal used to enable or disable the constraints
    signal {binary} enabled;
<% if (options.enableInput) { -%>
    signal input enable;
    enable * (enable - 1) === 0;
    enabled <== enable;
<% } else { -%>
    enabled <== 1;
<% } -%>

    // --> Proof elements

<%  if(starkInfo.nPublics > 0) { -%>
    // Public inputs
    signal input publics[<%- starkInfo.nPublics %>];

<%  } -%>
-%>
<%  if((starkInfo.airValuesMap && starkInfo.airValuesMap.length > 0) || (starkInfo.airgroupValuesMap && starkInfo.airgroupValuesMap.length > 0) || (starkInfo.proofValuesMap && starkInfo.proofValuesMap.length > 0)) { -%>
    // One-dimensional elements
<%  } -%>
<% if(starkInfo.airValuesMap.length > 0) { -%>
    signal input airvalues[<%- starkInfo.airValuesMap.length %>][3];
<% } -%>
<% if(starkInfo.airgroupValuesMap.length > 0) { -%>
    signal input airgroupValues[<%- starkInfo.airgroupValuesMap.length %>][3];
<% } -%>
<% if(starkInfo.proofValuesMap.length > 0) { -%>
    signal input proofvalues[<%- starkInfo.proofValuesMap.length %>][3];
<% } -%>

<% /* Depending on the STARK being verified, the rootC will be hardcoded or passed as an input */%>
    // Merkle tree roots of the fixed columns
<% if (options.verkeyInput) {  -%>
    signal input rootC[4];
<% } else { -%>
<%      if (options.inputChallenges) { -%>
    // Notice that it is set as an output so that it can be used outside this circuit
    signal output rootC[4] <== [<%- constRoot.join(',') %> ];
<%      } else { -%>
    signal rootC[4] <== [<%- constRoot.join(',') %> ];
<%      } -%>
<% } -%>

    // Merkle tree roots of the witness columns at each stage
<% for(let i=0; i < starkInfo.nStages; i++) {  -%>
<%  const stage = i + 1; -%>
    signal input root<%- stage %>[4];
<% } -%>
    signal input root<%- qStage %>[4];

    // Set of evaluations around the out-of-domain sample
    signal input evals[<%- starkInfo.evMap.length %>][3];

    // Merkle tree roots of the FRI polynomials for each layer during the commit phase
<% let si_roots = []; -%>
<% for (let s=1; s<starkStruct.steps.length; s++) {   -%>
<% si_roots.push(`s${s}_root`); -%>
    signal input s<%- s %>_root[4];
<% } -%>

    // Polynomial sent in clear in the last iteration of the FRI commit phase
    signal input finalPol[<%- 1 << starkStruct.steps[starkStruct.steps.length-1].nBits %>][3];

    // Set of evaluations and Merkle proofs for each of the <%- starkStruct.nQueries %> queries 
    // performed during the FRI query phase, covering all involved polynomials
    signal input s0_valsC[<%- starkStruct.nQueries %>][<%- starkInfo.nConstants %>];
    signal input s0_siblingsC[<%- starkStruct.nQueries %>][<%- starkStruct.steps[0].nBits %>][4];

<% for(let i = 0; i < starkInfo.customCommits.length; ++i) { -%>
    signal input s0_vals_<%- starkInfo.customCommits[i].name %>_0[<%- starkStruct.nQueries %>][<%- starkInfo.mapSectionsN[`${starkInfo.customCommits[i].name}0`] %>];
    signal input s0_siblings_<%- starkInfo.customCommits[i].name %>_0[<%- starkStruct.nQueries %>][<%- starkStruct.steps[0].nBits %>][4];
<% } -%>
-%>
<% for (let i = 1; i < starkInfo.nStages + 1; ++i) { -%>
<%  if (starkInfo.mapSectionsN[`cm${i}`] > 0) { -%> 
    signal input s0_vals<%- i %>[<%- starkStruct.nQueries %>][<%- starkInfo.mapSectionsN[`cm${i}`] %>];
    signal input s0_siblings<%- i %>[<%- starkStruct.nQueries %>][<%- starkStruct.steps[0].nBits %>][4];
<%  } -%>
<% } -%>                                       
    signal input s0_vals<%- qStage %>[<%- starkStruct.nQueries %>][<%- starkInfo.mapSectionsN[`cm${qStage}`] %>];
    signal input s0_siblings<%- qStage %>[<%- starkStruct.nQueries %>][<%- starkStruct.steps[0].nBits %>][4];

<% for (let s=1; s<starkStruct.steps.length; s++) {   -%>
    signal input s<%- s %>_vals[<%- starkStruct.nQueries %>][<%- (1 << (starkStruct.steps[s-1].nBits - starkStruct.steps[s].nBits))*3 %>];
    signal input s<%- s %>_siblings[<%- starkStruct.nQueries %>][<%- starkStruct.steps[s].nBits %>][4];
<% }                                                  -%>

    // --> Run the IOP verifier <--
<%- include("circuits.gl/stark_iop_verifier.circom.ejs", { calculateChallengesName, qStage, si_roots, verifyEvaluationsName, calculateFriQueriesName }) -%>

    // --> Run the LDT verifier <--
<%- include("circuits.gl/stark_ldt_verifier.circom.ejs", { qStage, calculateFRIPolName, verifyQueryName }) -%>
}
    
<% if (!options.skipMain) {  -%>
component main <%- starkInfo.nPublics > 0 ? "{public [publics]}" : ""%>= <%- verifierName %>();
<% } -%>