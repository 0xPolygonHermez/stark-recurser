<% if (!options.inputChallenges) { -%>

<%  let challengeNames = []; -%>
    // Proof challenges
<%  for(let i = 0; i < starkInfo.nStages; ++i) { -%>
<%  if(starkInfo.challengesMap.filter(c => c.stage === i + 1).length === 0) continue; -%>
    signal challengesStage<%- i + 1 %>[<%- starkInfo.challengesMap.filter(c => c.stage === i + 1).length %>][3];
<%      challengeNames.push("challengesStage" + (i + 1)); -%>
<%  }-%>

    signal challengeQ[3];
    signal challengeXi[3];
    signal challengesFRI[2][3];
<%      challengeNames.push(...["challengeQ", "challengeXi", "challengesFRI"]); -%>

    signal challengesFRISteps[<%- starkStruct.steps.length + 1 -%>][3];

    // Challenges from which we derive all the queries
    signal {binary} queriesFRI[<%- starkStruct.nQueries %>][<%- starkStruct.steps[0].nBits %>];

    // --> Derive challenges, challengesFRISteps and queriesFRI

<%  const stageRoots = []; -%> 
<%  for(let i = 0; i < starkInfo.nStages; i++) { stageRoots.push(`root${i + 1}`) } -%>
    (<%- challengeNames.join(",") %>,challengesFRISteps,queriesFRI) <== <%- calculateChallengesName %>()(<%- starkInfo.nPublics > 0 ? "publics," : "" %>rootC,<%- stageRoots.join(",") %>,root<%- qStage %>,evals<%- si_roots.length > 0 ? "," + si_roots.join(",") : "" %>,finalPol);

<% } else { -%>
    // --> VADCOP elements
<%  for(let i = 0; i < starkInfo.nStages; ++i) { -%>
<%  if(starkInfo.challengesMap.filter(c => c.stage === i + 1).length === 0) continue; -%>
    signal input challengesStage<%- i + 1 %>[<%- starkInfo.challengesMap.filter(c => c.stage === i + 1).length %>][3];
<%  }-%>

    signal input challengeQ[3];
    signal input challengeXi[3];
    signal input challengesFRI[2][3];
    signal input challengesFRISteps[<%- starkStruct.steps.length + 1 -%>][3];

    // Note: All challenges are set as inputs so the verifier assumes they have been correctly derived

    // --> Derive the FRI queries from the last challenge
    signal {binary} queriesFRI[<%- starkStruct.nQueries %>][<%- starkStruct.steps[0].nBits %>] <== <%- calculateFriQueriesName %>()(challengesFRISteps[<%- starkStruct.steps.length -%>]);
<% } -%>

<%      if (options.multiFRI) { -%>
    signal output queryVals[<%- starkInfo.starkStruct.nQueries %>][3];
<%      } -%>
-%>
<%  const verifyEvalsInputs = []; -%>
<%  verifyEvalsInputs.push("enabled"); -%>
<%  if(starkInfo.nPublics > 0) verifyEvalsInputs.push("publics"); -%>
<%  if(starkInfo.airValuesMap.length > 0) verifyEvalsInputs.push("airvalues"); -%>
<%  if(starkInfo.airgroupValuesMap.length > 0) verifyEvalsInputs.push("airgroupValues"); -%>
<%  if(starkInfo.proofValuesMap.length > 0) verifyEvalsInputs.push("proofvalues"); -%>
-%>
<%  for(let i = 0; i < starkInfo.nStages; ++i) { -%>
<%      const stage = i + 1; -%>
<%      if(starkInfo.challengesMap.filter(c => c.stage === stage).length === 0) continue; -%>
<%      verifyEvalsInputs.push("challengesStage" + stage); -%>
<%  } -%> 
<%      verifyEvalsInputs.push("challengeQ"); -%>
<%      verifyEvalsInputs.push("challengeXi"); -%>
<%      verifyEvalsInputs.push("evals"); -%>
-%>
    // --> Perform the consistency check around the out-of-domain sample Xi, i.e., check that the expressions:
    //        Q1(X) + X^n*Q2(X) + X^(2·n)*Q3(X) + ... X^((qDeg-1)·n)*Q(X),
    //        q_0(X) + challenge * q_1(X) + challenge^2 * q_2(X) + ... + challenge^(l-1) * q_l-1(X),
    //     are equal at Xi.
    <%- verifyEvaluationsName %>()(<%- verifyEvalsInputs.join(", ") %>);
